# Introduction
## 0!

(here)[http://btholt.github.io/four-semesters-of-cs/] is a link to the course website.

Read Cormen's intro to Algorithms.

# Big O
## 06:27

Pay attention to the parts that will have the bigget impact on our process. For example, what is causing the biggest change in the processing time?

Meaning, if x^3 + x + 2 is the formula, x + 2 will not change the order of magnitude much. Most of the magnitude will change in the x^3 part of the formula.

sample function:
```
function crossAdd(input) {
    var answer = [];
    for (var i = 0; i < input.length; i++) {
        var goingUp = input[i];
        var goingDown = input[input.length-1-i];
        answer.push(goingUp + goingDown);
    }
    return answer;
}
```
We go over everything once, so this is o(n) (o to the nth power).

If you are finding something in an array, youstill have o(n), assuming the result is the last item in the array

Below, you have a loop in a loop, so it is different:
```
function makeTuples(input) {
    var answer = [];
    for (var i = 0; i < input.length; i++) {
        for (var j = 0; j < input.length; j++) {
            answer.push([input[i], input[j]]);
        }
    }
    return answer;
}
```

This would be o(n^2), because you are looping inside of a loop.

Every time you see for, while, or in, you are doing a nested-loop. This will add the most time to your processes 95% of the time.

If there are no loops, o(1)

o(log n)
This will be **recursion** and will take less and less time, the less items you have in the list.

# Recursion
## 0:18

**recursion** is when you use something to define itself.
Favor readability over performance.

# Recursion Example
## 0:22

The first line of recursion should always be a return statement, to tell when to stop to prevent a stack overflow.

Fibonacci.
1, 1
2, 1. - self, so 2, 1
3, 2. Add the "y" of the last two digist: 1 and 1.
4, (2 + 1)
5, 5 (3 + 2)
6, 8 (5 + 3)
7, 13 (8 + 5)

# Recursion
## 0:34

It is like the inner part of a loop. Whatever is in the middle of the loop is the part that gets run multiple times.
