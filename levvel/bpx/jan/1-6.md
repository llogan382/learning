## Call w Jim

https://github.com/GetLevvel/bpx-server/tree/dev

RTL confirmation Advice. This is consumer maintenance.

Looking at the BPX v2.3 pdf

There are three of them. Payment ackknowledgement req and response.

Starting with "request for payment"
BPX does an async callback to a SOAP endpoint.
We are going to do an asyn callback to PR


We take XML, change it, and push to the restful endpoint.
Then, we get the reply (as JSON), and convert, and send back to soap server.

## We are the `bill pay exchange` here

We have to setup a server.
SOAP4R.
It can do 1 document at a time. The problem is that it works with webrick, a dev ruby server.

RUBY has a web server named PUMA.
With PUMA, we would not have to do SSL on it.

How can we hookup ruby with NGINX?
Ruby rack. It is a great design pattern.
It is an interface.

It decouples from the server.
It supports PUMA and nginx

github.com/rack.rack

Now, we need to build a rack application.
'rack applicateion` is a phrase that
It is set up as a web server.

Chaining: responding based on certain criteria.
Each criteria in the chain is an endpoint.

`Config.ru`  is the configuration.
Run it using `rackup` as the command in the terminal.

In the gemspec, it can use webrick as the default local setup.
Change `webrick` to `puma` and you will be set for production instead of dec.

Jim tested using SOAPui, and it works.

`rack` runs everyting in the config.ru file.
Rack knows what to do in this file, going from endpoint to endpoint.

in `/bpx_server/config` there is a settings file. Jim is still setting them up.

Settings can be overrridden in the client.
Some of the patterns are the same.

The `callback_url` is `localhost`, but PR will have to provide us with one.
Jim filled in this info for now.
PR wil set up endpoints for each of these.

`soap4r-middleware` is the gem.
we want 1 server w 3 methods.
How can we mashup the endpoints into 1 server?
Take the generated files, copy it, and run it against the gem.
`rackmw` is rack middleware.
There are naming collisions, so items had to be separated into different files.
Almost everything here is generated code. Same with `mappings.rb`

`rtlconfirm`
A TON of classes are created. A class is created for every XML schema.

The docs created by yard will help me create what I need to create.

Now, I need to create deeply nested objects.

Looking at `rack_me.rb`, the soap server is set up.
The mappings have all the classes.
`mappingregistry` is how the ruby  ties things together.
This will be used instead of nokogiri.

There is only 1 file to work on:
`service_impl.rb` (for each service of course. )
`rtl_confirm` is what Jim has worked the most on

do `req_for_pmt` last bc it is so big.
in the `/spec` directory:
in `rtl_confirm` spec: the header test will

`rtl_confirm_spec`: there is a context that is created.
The `env` is loaded and populated.
It looks up the path.

Jim used the response in the gooogle drive as the sample response payloads.
The response is based on the `rain` file being used.
Then, put them together in the `test_payloads` with an envelope, header, and body.

All of the responses are being simulated.
The rack middleware gets called in the reponse *line 12 of `rtl_confirm_spec`)

Jim ran this against a test server that he created.
The response will pass/fail, and generate a soap response.
(at 1:28 on Jim's computer clock)

Running the debugger gives the soap request.
The `soap_request` has an app header and a message.
Now, it is not XML, it is a ruby hierarchy of objects.
He ran the debugger on `rtl_confirm/service_impl.rb`

JSON is being created (line 48) .
Line 51 uses `to_json` to convert.

If we just convert the thing to JSON, Payrailz can decide what to do with it.

(line 33):
Call rest service.
Line 59: provide the URL, the path, the rest_url, etc.

THe real pain in the butt: (line 73):
build the document.
Use the documentation to do this.
The documentation tells all of the required fields.
You can get the hierarchy
Building an XML object structure that mimics the XML structure.
This is tedious, and most of the work will be done here.

## The final thing:
Jim has done this tones of times.
(1:39 on Jim clock)
Swagger. Jim has an acct.
He built a swagger file. It has all definitions, examples, etc.
And, it can EXPORT everything that can be used for documentation OR the server files.

This is the equivalent of a JSON schema.
(it looks like graphql)

Jim created one for the three callbacks we are using.
Take the `json` format, and convert it into a swagger file.

Swagger is creating a slimmed down version of the response we are sending.

We will get the object back, parse it, and see if it is a success or  fail.

now 1:45 on jims computer.
Then, we jump to the conditionals: line 104 in the `rtl_confirm` file.

Jim vcan


### Call with Mike
Jim: What needs to be done: create the SSL handshake. We will give it a test to see if it connects.

Luke: Almost all is done for the services, except the CFI endpoints (which are a SOAP endpoint).

Jim: We have a soap server, and a REST server setup

CFIs are ENDPOINTS (where we call them)
other services are CLIENTS (where they call us)

All we have to do is stub out (fill in) the other services.

Mike: Come to the table monday with an idea of what the knowledge transfer will look like.

Jim: They need to implement this on their (the payrailz) environemtn. Use cases and a test suite will need to be written.

Mike: Masons next project got delayed. Can we get luke on VPN with PR?

Jim: Next week, billable customers get 1st priority. But I dont want to promise more because I dont know what to expect.

Mike: Whatever PR does, I might need to help setup their environment. This depends on Paul's response.

two types of exceptions: Business exceptions, and wire exceptions.

Mike: If PR wants to go knowledge transfer, can we invite to our github?

Jim: Don't give them write access yet.

Mike: Paul might want us to work with their devs.

Jim: Two teams in the code is for Mike to discuss with PR.

Mike: They should have at least read access.

Jim and mason are going to connet with a VPN connection.



##