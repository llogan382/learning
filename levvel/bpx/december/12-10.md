# From RSPEC course

to view the contents of the rspec file, run:
`rspec --format doc filename.rb`


**describe** groups examples together.

**it** specifies properties

## Documentation for RSPEC
go to [relishapp.com/rspec/rspec-core/docs]

Also, rspec.info for rspec-core.

`rspec --format doc --color card.rb`

you can format the response:
`rspec --format html --color card.rb`


## IMPORTANT:
Test for BEHAVIOR, not IMPLEMENTATION

## WHY are we writing specs?

The benefit is CONFIDENCE that the code works. It is not a PROOF of all edge cases.

One BRANCH/METHOD per spec.`


**A test should only change when the behavior changes**

Setup default parameters for the test, so they dont break as easily:
```
    def card(params = {})
        defaults = {
            suit: :hearts,
            rank: 7,
        }

        Card.new(**defaults.merge(params))
    end
```

You can create METHODS that help for testing, to test for BEHAVIORS. in this case, coding for HASH and EQL
```
    def hash
        [rank, suit].hash
    end

    def eql?(other)
        self == other
    end
```

### Shared examples
Still in RSPEC. These can be used in MULTIPLE PLACES, just like including a Ruby Module


Here is the code I wrote:
```
require 'spec_helper'


RSpec.describe Card do

    def card(params = {})
        defaults = {
            suit: :hearts,
            rank: 7,
        }
        Card.build(*defaults.merge(params).values_at(:suit, :rank))
    end

    it 'has a suit' do
        raise unless card(suit: :spades).suit == :spades
    end

    it 'has a rank' do
        raise unless card(rank: 4).rank == 4
    end

    context 'equality' do
        subject { card(suit: :spades, rank: 4) }
        let(:other) { card(suit: :spades, rank: 4) }


        describe 'comparing against self' do

            it 'is equal to itself' do

                raise unless subject == other
            end
            it 'is hash equal to itself' do
                raise unless Set.new([subject, other]).size == 1
            end
        end

        shared_examples_for 'an unequal card' do

            it 'is not equal' do
                raise unless subject != other
            end
            it 'is not hash equal' do
                raise unless Set.new([subject, other]).size == 2
            end
        end

        describe 'comparing a card of different suit' do
            let(:other) { card(suit: :hearts, rank: 5) }
            it_behaves_like 'an unequal card'
        end

        describe 'comparing a card of different rank' do
            let(:other) { card(suit: :spades, rank: 5) }
            it_behaves_like 'an unequal card'
        end
    end

    describe 'A queen' do
        it 'rankshigher than a jack' do
            lower = card(rank: :jack)
            higher = card(rank: :queen)
            raise unless higher.rank > lower.rank
        end
    end

    describe 'A jack' do
        it 'has a rank higher than 10' do
            lower = card(rank: 10)
            higher = card(rank: :jack)
            raise unless higher.rank > lower.rank
        end
    end
end

```


# Daily Standup

Started recording in DOCUMENTS

Chris: Will work on Status Update, but this meeting may be cancelled. No blockers

Jim: Researched dependency injection, wont work much on what we are doing. Worked on PRY for debugging.
I want to show Bharghav and Luke what I am stuck on.

Mason: Gave some recommendations for what I am working on; watch this on the recording of todays video.

Bharghav: After we get response, we need to send confirmation to BSP

Mason: BSP ID should come from customer. We were given a preferred ID. BSP - biller service provider. Biller is where customer links to the biller.
Now that we have a customer, we link that customer to the biller ID.
It is not like the BPX ID, assigned to PAYRAILZ.

Bharghav: We dont need to worry about BSP?

Mason: If customer picks something not available, they should get an error.

Jim: If there is an error code, all services have an error code. Those will need to be parsed.
The ERROR OBJECT will be common against all services.

Bharghav: I am working on a response object, and BSP ID.

Mason: I talked with Devops Guy- for VPN.

Chris: Payrailz is looking to us to run those daily meetings. Updates should provide roadblocks from PAYRAILZ during payrailz calls.

Chris: At some point, we have to show our cards (watch this part of the video)
We will tell client we are not BPX experts.
Payrailz (paul from that company) knows their code and expectations better than we do; they dont know we dont know this stuff :(

Mason: Since we dont have any active connections, can we setup our own mock server, so we can demo it? If we can do that, we will have a better leg to stand on.

Chris: We can tell Payrailz we can do the mapping.

Mason: The original services will be done, we are not ready to do the rest (in terms of mapping)

## Standup pt 2 video

Talking about GIT.

Bharghav: Git pull origin before merging your branch (to make sure that you pull DEV changes before merging.)

Jim: Shares his code about dependency injection.
Looking at `autoload :Service`
Items were not being loaded.


What am I trying to do?
The DEV branch isnt working




# Payrailz Call 12-10


People:

SONG snunnallee@payrailz.com
Bhargav Dasari
Christopher Rigoni II
Hornghtern@payrailz.com
LISA lgawlak@payrailz.com
luke.logan@levvel.io
Mason Packard
PAUL? pfranko@payrailz.com
ddelisle@payrailz.com
glangmeyer@payrailz.com
James Boone

Song:
Someone will get you access to all of the VPN info, etc.
Lisa is the new SR product manager.
Today we are talking about data mapping.
(I muted the video at this point- does this still record?)

Horng wants Code to be reviews. Looking at mapping is not too helpful.

Mason: Devs want to have access to the data.

Song: Everyone has VPN access, except Luke.
H: We need to check with BPX to troubleshoot the errors that we are seeing for API calls.

Song: Dan at Mastercard is working on this.






### Today's schedule:
Until 11:45:
Rspec Course

Until 1:
Meeting with Payrailz

Until 3:
Rspec Course

Until 5:
Write a parser to take XML response.
In businessAppHdrResponse, create a class `BusinessApplicationHeaderResponse`



Make a test for XML response
Fix code and change XML file to `data` directory
## Todos:

- [ ] Write a parser to take the XML response, turn it into the response object. Validate the response as a RUBY object, not XML. Use SAVON for this (masons recommendation). review video or Mason's recommendation.
- [ ] Rewatch video parts noted above.
- [ ] Learn `autoload` with Ruby
- [ ]
- [ ]
- [ ]
- [ ]
- [ ]
- [ ]


